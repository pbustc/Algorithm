# 约瑟夫环

## [剑指 Offer 62. 圆圈中最后剩下的数字]

0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

### 不同下标取余

一般的序列有从1开始计数和从0开始计数两种，其取余的细节有些许不同。

首先，取余是得到整数除法中被除数未被除尽部分。

个人理解，在序列中， 体现为从第1个下标开始往后数，数到结尾时回到第一个下标的位置，最后停留的地方即为结果。

设有n个数，取出索引为 m % n 的数。

- 下标从1开始的序列

1，2，3，4，5，6 ...... n

当 m < n时，取出下标为 m 的数

当m == n时，取出下标为 n 的数

当m > n时，取出下标为 m % (n + 1) + 1 位置的数

- 下标从0开始的序列

0，1，2，3，4 ...... n

当m <=  n 时，取出下标为m - 1的数

当m == n + 1，取出下标为m - 1的数

当m > n + 1，取处下标为 (m - 1) % n  位置的数

### 约瑟夫环问题求解

从数字0开始，每次从这个圆圈里删除第m个数字，删除n - 1个数字后得到最终的答案。

设 f(n , m)表示0，1，2 ...... n - 1围成的圆圈，每次删除第m个数字得到的最终答案。

f(n , m)删除的第一个数字为 (m - 1) % n

令 t = m % n，即删除第一个数字后面的那一位

删除后从 t + 1开始计数，形成的新序列为：

t ，t + 1，t + 2 ...... n - 1，0，1，2 ...... t - 3，t - 2

| f(n - 1, m)问题下标 | f(n , m)问题删除第一个数后对应的下标 |
| ------------------- | ------------------------------------ |
| 0                   | t                                    |
| 1                   | t  + 1                               |
| ......              | ......                               |
| n - t - 2           | n - 2                                |
| n - t - 1           | n - 1                                |
| n - t               | 0                                    |
| n - t  + 1          | 1                                    |
| ......              | ......                               |
| n - 1               | t - 3                                |
| n - 2               | t - 2                                |

设f(n - 1,m)问题中一下标为x，f(n , m)中对应的下标为：

 **(x + t) % n**  

所以  **f(n , m) = ( f(n - 1, m) + t ) % n** --> **f(n , m) = ( f(n - 1 , m) + m % n) % n = ( f( n - 1 , m) + m ) % n**

此公式的本质在于： 求出f( n - 1 , m)的最终答案在f(n , m)中的位置

有两种求解方式：

#### 1. 自顶向下的递归

```
class Solution {
public:
    int lastRemaining(int n, int m) {
        return f(n , m);
    }
private:
    int f(int n , int m){
        if(n == 1){return 0;}
        return (f(n - 1 , m) + m) % n;
    }
};
```

#### 2. 自底向上的DP

```
class Solution {
public:
    int lastRemaining(int n, int m) {
        int f1 = 0 , ans = 0;
        for(int i = 1;i <= n;++i){
            ans = (f1 + m) % i;
            f1 = ans;
        }
        return f1;
    }
};
```

## 