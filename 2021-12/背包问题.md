# 背包问题

在刷lc时多次遇到了背包问题，但都没有深入去思考，这次借着算法的实验五对其进行深入的学习：

​		**背包问题**（Knapsack problem）是一种[组合优化]的NPC问题。		

​		背包问题泛指这类种问题： 给定一组有**固定价值和固定重量的物品**， 以及一个已知最大
承重量的背包， 求在不超过背包最大承重量的前提下， 能放进背包里面的物品的最大总价值。
具体各类背包问题可以分成以下 3 种不同的子问题。  

## 0-1背包问题	

我们有*n*种物品，物品*j*的重量为*wj*，价格为*pj*。
 我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为*W*。
 如果限定每种物品只能选择0个或1个，则问题称为**0-1背包问题**。

解决方法：

- 动态规划
- 贪婪算法
- 回溯法
- 分支确定法



**问题描述：** 有编号分别为 a,b,c,d,e 的五件物品， 它们的重量分别是 2,2,6,5,4， 它们的价值分别是 6,3,5,4,6， 每件物品数量只有一个， 现在给你个承重为 10 的背包， 如何让背包里装入的物品具有最大的价值总和？ 

 

#### 动态规划求解

动态规划的关键是将问题分解为更小的、相似的子问题，存储子问题的解而避免重复计算以优化求解的过程；

分为：

- 自底向上的动态规划
- 带备忘录的自顶向下法 --- 记忆化搜索

求解步骤：

1. 寻找子问题：分析---最终求解的问题需要知道指定承重的背包具有的最大价值总和，我们可以将求解问题的过程视为对每一个物品的选择问题，即f(i,j)代表选择到第i个物品，容纳重量为j时的最大价值。

2. 递归定义最优解：

   **f(i , j) = max(f(i - 1 , j ) , f(i - 1 , j - wi))**  即对于第i个物品是否选择发生一个决策

```
	int getMostValue_dp(vector<int> &weight, vector<int> &value, int n) {
		int m = weight.size();
		vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
		for (int i = 0;i < m;++i) {
			for (int j = 0;j < n;++j) {
				dp[i + 1][j + 1] = dp[i][j + 1];
				if (j > weight[i]) dp[i + 1][j + 1] = max(dp[i + 1][j + 1] , dp[i][j + 1 - weight[i]] + value[i]);
			}
		}
		return dp[m][n];
	}
```



#### 回溯法

回溯法先确定解空间的结构， 使用深度优先搜索， 搜索路径一般沿树形结构进行， 在搜索过程中， 首先会判断所搜索的树结点是否包含问题的解， 如果肯定不包含， 则不再搜索以该结点为根的树结点， 而向其祖先结点回溯； 否则进入该子树， 继续按深度优先策略搜索。运用回溯法解题通常包含以下三个步骤：
a. 针对所给问题， 定义问题的解空间；
b. 确定易于搜索的解空间结构；
c. 以深度优先的方式搜索解空间， 并且在搜索过程中用剪枝函数避免无效搜索；  

```
int getMostValue_bt() {
		int ans = 0;
		backtracking(0, 0 , 0, ans);
		return ans;
	}
```

```
vector<int> w;
	vector<int> v;
	int s;
	int m;
	void backtracking(int start , int cursize, int curValue, int &ans) {
		if (cursize > s) return;
		if (start == m) {
			ans = max(ans, curValue);
		}
		for (int i = start;i < m;++i) {
			backtracking(i + 1, cursize + w[i], curValue + v[i], ans);
		}
		return;
	}
```



#### 分支界定法

分支限界法类似于回溯法， 也是在问题的解空间上搜索问题解的算法。
分支限界法首先要确定一个合理的限界函数（ bound funciton） ， 并根据限界函数确定目标函数的界[down ,up]， 按照广度优先策略或以最小耗费优先搜索问题的解空间树， 在分直结点上依次扩展该结点的孩子结点， 分别估算孩子结点的目标函数可能值， 如果某孩子结点的目标函数可能超出目标函数的界， 则将其丢弃； 否则将其加入待处理结点表（ 简称 PT表） ， 依次从表 PT 中选取使目标函数取得极值的结点成为当前扩展结点， 重复上述过程，直到得到最优解。  

