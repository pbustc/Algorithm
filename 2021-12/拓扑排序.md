# LEETCODE --- 851

有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 "person x "。

给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自洽（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。

现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。

## 自己的思路

```
class Solution {
public:
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        vector<int> ans;
        unordered_map<int , set<int>> map;
        for(auto x : richer){
            map[x[1]].insert(x[0]);
            for(auto & y : map){
                 // 比x[1]小的数必然比x[0]小
				 if (y.second.find(x[1]) != y.second.end()) y.second.insert(x[0]);
				 // 比x[0]大的数必然比x[1]大
				 if (y.first == x[0]) {
					 for (auto & z : y.second) {
						map[x[1]].insert(z);
					}
				 }
            }
        }
        for(int i = 0;i < quiet.size();++i){
            int min_quiet = quiet[i];
            int min_index = i;
            for(auto y : map[i]){
                if(quiet[y] < min_quiet){
                    min_quiet = min(min_quiet , quiet[y]);
                    min_index = y;
                }
            }
            ans.emplace_back(min_index);
        }
        return ans;
    }
};
```

通过哈希表把比每个人富有的人索引存到set，这样做会导致时间复杂度增加到最多O(n^2)，发生了超时。

## 2.拓扑排序

题目已经说明，逻辑自洽，在 person `x` 比 person `y` 更有钱的同时，不会出现 person `y` 比 person `x` 更有钱的情况，那么他们的财富的递减顺序可作为有向无环图的指向方向。

在拓扑排序的输出过程中，记录下每条路径中最小的quiet值，便是题目所要求的answer[x] = y，所有拥有的钱不少于person[x]的人中，最安静的人。

**在图论中，一个有向无环图必然存在至少一个拓扑序与之对应**

同时，需要了解出度和入度的概念

- 入度：有多少条边直接指向该节点；
- 出度：由该节点指出边的有多少条。

### 拓扑排序的输出

可以使用BFS方式输出有向图的拓扑排序：

1. 起始时，将所有入度为 0 的节点进行入队（入度为 0，说明没有边指向这些节点，将它们放到拓扑排序的首部，不会违反拓扑序定义）
2. **从队列中进行节点出队操作，出队序列就是对应我们输出的拓扑序**。对于当前弹出的节点 x，遍历 x 的所有出度，即遍历所有由  x直接指向的节点 y，对 y 做入度减一操作
3. 对 y 进行入度减一之后，检查 y 的入度是否为 0，如果为 0 则将 y 入队
4. 循环流程 2,3 直到队列为空

```
class Solution {
public:
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        vector<int> ans(n);
        vector<vector<int>> w(n , vector<int> (n , 0));
        vector<int> in(n , 0);
        for(auto &x : richer){
            w[x[0]][x[1]] = 1;
            in[x[1]] += 1;
        }
        queue<int> q;
        for(int i = 0;i < n;++i){
            ans[i] = i;
            if(in[i] == 0) q.push(i);
        }
        while(!q.empty()){
            int t = q.front();
            q.pop();
            for(int i = 0;i < n;++i){
                if(w[t][i] == 1){
                    if(quiet[ans[i]] > quiet[ans[t]]) ans[i] = ans[t];
                    if(--in[i] == 0) q.push(i);
                }
            }
        }
        return ans;
    }
};
```

